import TensorFlow

% dims = range(1, 13)
% for dim in dims:
% if dim <= 3:
%   coordinates = ['x', 'y', 'z'][0:dim]
% else:
%   coordinates = ['s%d' % i for i in range(dim)]
% end

/// An element of R^${dim}, with Euclidean inner product.
public struct Vector${dim}: KeyPathIterable {
  % for coordinate in coordinates:
  @differentiable public var ${coordinate}: Double
  % end

  @differentiable
  public init(${', '.join(['_ %s: Double' % c for c in coordinates])}) {
    % for (index, coordinate) in enumerate(coordinates):
    self.${coordinate} = ${coordinate}
    % end
  }
}

/// Conformance to Vector
extension Vector${dim}: AdditiveArithmetic, Vector {
  @differentiable
  public static func += (_ lhs: inout Self, _ rhs: Self) {
    % for coordinate in coordinates:
    lhs.${coordinate} += rhs.${coordinate}
    % end
  }

  @differentiable
  public static func -= (_ lhs: inout Self, _ rhs: Self) {
    % for coordinate in coordinates:
    lhs.${coordinate} -= rhs.${coordinate}
    % end
  }

  @differentiable
  public static func *= (_ lhs: inout Self, _ rhs: Double) {
    % for coordinate in coordinates:
    lhs.${coordinate} *= rhs
    % end
  }

  @differentiable
  public func dot(_ other: Self) -> Double {
    var result = Double(0)
    % for coordinate in coordinates:
    result += self.${coordinate} * other.${coordinate}
    % end
    return result
  }

  public var dimension: Int { return ${dim} }

  public static var standardBasis: [Self] {
    var result = Array(repeating: Self.zero, count: ${dim})
    % for (i, coordinate) in enumerate(coordinates):
    result[${i}].${coordinate} = 1
    % end
    return result
  }

  public init<Source: Collection>(_ scalars: Source) where Source.Element == Double {
    var index = scalars.startIndex
    % for coordinate in coordinates:
    self.${coordinate} = scalars[index]
    index = scalars.index(after: index)
    % end
  }

  public struct Scalars: RandomAccessCollection, MutableCollection {
    public typealias Indices = Range<Int>
    internal var base: Vector${dim}
    public var startIndex: Int { 0 }
    public var endIndex: Int { base.dimension }
    public subscript(i: Int) -> Double {
      get {
        precondition(i >= 0 && i < endIndex)
        return withUnsafePointer(to: self) {
          UnsafeRawPointer($0).assumingMemoryBound(to: Double.self)[i]
        }
      }
      _modify {
        precondition(i >= 0 && i < endIndex)
        let p = withUnsafeMutablePointer(to: &self) { $0 }
        let q = UnsafeMutableRawPointer(p).assumingMemoryBound(to: Double.self)
        yield &q[i]
        _fixLifetime(self)
      }
    }
  }
  
  public var scalars: Scalars {
    get { .init(base: self) }
    set { self = newValue.base  }
  }
}

extension Vector${dim}: FixedSizeVector {
  public static var dimension: Int { return ${dim} }
}

extension Vector${dim}: ElementaryFunctions {}

% end
