import Foundation
import TensorFlow
import XCTest

import SwiftFusion

% import math
% dims = range(1, 10)

class VectorNTests: XCTestCase {
  % for dim in dims:
  % if dim <= 3:
  %   coordinates = ['x', 'y', 'z'][0:dim]
  % else:
  %   coordinates = ['s%d' % i for i in range(dim)]
  % end
  % values1 = range(1, dim + 1)
  % values2 = range(dim + 1, 2 * dim + 1)

  /// Test that initializing a vector from coordinate values works.
  func testVector${dim}Init() {
    let vector1 = Vector${dim}(${', '.join([str(v) for v in values1])})
    % for (index, coordinate) in enumerate(coordinates):
    XCTAssertEqual(vector1.${coordinate}, ${values1[index]})
    % end
  }

  /// Test that the vector has the correct dimension.
  func testVector${dim}Dimension() {
    XCTAssertEqual(Vector${dim}.dimension, ${dim})
  }

  /// Test that vector `==` works.
  func testVector${dim}Equality() {
    let vector1 = Vector${dim}(${', '.join([str(v) for v in values1])})
    let vector2 = Vector${dim}(${', '.join([str(v) for v in values2])})
    XCTAssertTrue(vector1 == vector1)
    XCTAssertFalse(vector1 == vector2)
  }

  /// Test that vector sum works.
  func testVector${dim}Sum() {
    let vector1 = Vector${dim}(${', '.join([str(v) for v in values1])})
    XCTAssertEqual(vector1.sum(), ${sum(values1)})
  }

  /// Tests that `Vector${dim}.TangentVector == Vector${dim}`.
  func testVector${dim}TangentVector() {
    let vector1 = Vector${dim}(${', '.join([str(v) for v in values1])})
    let _: Vector${dim}.TangentVector = vector1
  }

  /// Tests that the move (exponential map) operation works on vectors.
  func testVector${dim}Move() {
    let vector1 = Vector${dim}(${', '.join([str(v) for v in values1])})
    let vector2 = Vector${dim}(${', '.join([str(v) for v in values2])})
    var moved = vector1
    moved.move(along: vector2)
    % for (index, coordinate) in enumerate(coordinates):
    XCTAssertEqual(moved.${coordinate}, ${values1[index] + values2[index]})
    % end
  }

  /// Tests that conversion to `Vector` works.
  func testVector${dim}ConvertToVector() {
    XCTAssertEqual(
      Vector${dim}(${', '.join([str(v) for v in values1])}).vector,
      Vector([${', '.join([str(v) for v in values1])}])
    )
  }

  /// Tests that conversion from `Vector` works.
  func testVector${dim}ConvertFromVector() {
    XCTAssertEqual(
      Vector${dim}(Vector([${', '.join([str(v) for v in values1])}])),
      Vector${dim}(${', '.join([str(v) for v in values1])})
    )
  }

  /// Tests that we can initialize a vector from a tensor.
  func testVector${dim}TensorInit() {
    let vector1 = Vector${dim}(${', '.join([str(v) for v in values1])})
    let tensor1 = Tensor<Double>([${', '.join([str(v) for v in values1])}])
    XCTAssertEqual(Vector${dim}(tensor1), vector1)
  }

  /// Tests that we can extract a tensor from a vector.
  func testVector${dim}TensorExtract() {
    let vector1 = Vector${dim}(${', '.join([str(v) for v in values1])})
    let tensor1 = Tensor<Double>([${', '.join([str(v) for v in values1])}])
    XCTAssertEqual(vector1.tensor, tensor1)
  }

  % end
}

% for dim in dims:
/// Tests the `EuclideanVector` requirements.
class Vector${dim}EuclideanVectorTests: XCTestCase, EuclideanVectorTests {
  var dimension: Int { return ${dim} }

  var basisVectors: [Vector${dim}] {
    return (0..<dimension).map { index in
      var v = Array(repeating: Double(0), count: dimension)
      v[index] = 1
      return Vector${dim}(Vector(v))
    }
  }

  func makeVector(from start: Double, stride: Double) -> Vector${dim} {
    return Vector${dim}(Vector(Array((0..<dimension).map { start + Double($0) * stride })))
  }

  func testAll() {
    runAllTests()
  }
}
% end
